# ZIP Cracker 4.0.5

ZIP Cracker是一个现代化的加密文件破解工具，提供图形界面帮助用户尝试恢复忘记密码的加密文件。

## 主要功能

- **多种文件格式支持**：支持ZIP、RAR、7Z、PDF和Office文档等多种加密文件格式
- **多种攻击模式**：
  - 字典攻击（使用密码字典）
  - 掩码攻击（使用特定模式）
  - 字典+规则攻击（应用变换规则）
  - 组合攻击（组合多个字典）
  - 混合攻击（字典与掩码结合）
- **内置工具**：
  - 掩码生成器（根据密码特征生成掩码）
  - 字典管理器（管理本地字典，下载常用字典）
  - 性能设置（优化资源使用）
- **GPU加速支持**：支持使用GPU加速破解过程
- **自动下载**：内置工具自动下载功能
- **破解历史**：记录和管理破解历史

## 安装

### 系统要求

- Windows 10/11（64位）
- Python 3.6+
- PyQt5

### 安装步骤

1. 克隆或下载项目
2. 安装依赖库
```
pip install -r requirements.txt
```
3. 运行程序
```
python zipcracker.py
```

## 外部依赖

本程序使用以下外部工具进行哈希提取和破解：

- **John the Ripper**：用于提取哈希
- **Hashcat**：用于高性能破解

程序会自动下载这些工具，或者您可以在设置中手动配置路径。

## 注意事项

1. 本工具仅用于帮助用户恢复自己的密码，不得用于非法用途
2. 高强度密码破解可能需要大量时间和计算资源
3. GPU加速需要支持CUDA（NVIDIA）或OpenCL（AMD）的显卡

## 技术架构

- 使用PyQt5构建图形界面
- 多线程设计，保证UI响应性
- 模块化架构，便于扩展

## 许可

© 2023-2024 ZIPCracker Team. 保留所有权利。

# 常见问题（FAQ）

**1. 启动后提示缺少 zipcracker_ui.py 或其他 py 文件？**
- 请确保所有核心 py 文件（如 zipcracker_ui.py、zipcracker_dialogs.py 等）都已包含在打包或分发目录中。
- 使用官方 build.py 脚本打包可自动处理依赖。

**2. 配置文件和历史记录需要手动创建吗？**
- 不需要。首次运行程序时会自动在当前目录生成 zipcracker_config.json 和 crack_history.json。

**3. 如何切换主题或调整界面字体？**
- 在"设置"中可切换深色/浅色主题，调整字体大小。

**4. 破解历史如何导出？**
- 在历史记录界面可一键导出为 CSV、JSON 或文本格式。

**5. 支持哪些文件类型？**
- 支持 ZIP、RAR、7Z、PDF、Office 文档等主流加密文件。

**6. 破解速度慢/破解失败？**
- 建议优先使用 GPU 加速，或尝试更丰富的字典和掩码。
- 检查 hashcat、John the Ripper 路径设置是否正确。

**7. 运行环境要求？**
- Windows 10/11，Python 3.6+（源码运行时），或直接使用打包好的 EXE。

---

如有更多问题，请查阅帮助文档或联系 ZIPCracker Team。

# 破解流程详解

本节详细介绍 ZIP Cracker 的实际破解操作方法，适用于所有支持的加密文件类型。

## 1. 环境准备

- 安装依赖：`pip install -r requirements.txt`
- 确保已下载并配置好 John the Ripper、Hashcat（首次运行可自动下载或在"设置-工具路径"中手动指定）。
- 建议将程序放在纯英文路径下，避免中文目录导致工具异常。
- 推荐使用支持 OpenCL/CUDA 的显卡以获得最佳性能。

## 2. 破解流程

### 步骤一：选择加密文件并提取哈希
1. 启动程序，点击左上角"文件"→"打开文件"，选择需要破解的加密文件（ZIP、RAR、7Z、PDF、Office等）。
2. 在左侧"哈希提取"卡片，点击"提取哈希"按钮，程序会自动调用 John the Ripper 提取哈希值。
3. 提取成功后，哈希值会显示在文本框中，点击"复制哈希"可复制内容。

### 步骤二：选择攻击模式和参数
1. 在"攻击模式"卡片选择合适的攻击方式：
   - 字典攻击：适合常见弱密码，需选择字典文件。
   - 组合攻击：两个字典组合爆破。
   - 掩码攻击：适合已知部分密码特征（如长度、字符类型）。
   - 混合攻击：字典与掩码结合。
   - 暴力攻击：全字符集穷举，适合短密码。
2. 根据模式填写字典路径、掩码、规则等参数。可点击"浏览"或"生成"按钮辅助选择/生成。
3. 如需管理或下载字典，点击"字典管理"进入本地/在线字典管理器：
   - 在线字典可直接下载（需科学上网）或复制下载地址手动下载。
   - 支持导入自定义字典。

### 步骤三：性能设置与破解引擎
1. 在"破解操作"卡片选择"CPU"或"GPU"引擎。
2. 如需调整线程数、GPU设备、负载等，点击"设置-性能设置"进行高级配置。

### 步骤四：开始破解
1. 检查参数无误后，点击"开始破解"按钮。
2. 破解过程中可实时查看日志输出、破解进度和用时。
3. 破解成功后，密码会显示在"密码"框，并可一键复制。

### 步骤五：暂停/恢复/保存进度
- 破解过程中可点击"暂停破解"按钮，进度会自动保存（生成 .restore 文件）。
- 可在"文件"菜单选择"保存破解进度"，将 .restore 文件和参数导出。
- 需要断点续破解时，选择"加载破解进度"，导入 .restore 文件后点击"继续破解"。

### 步骤六：保存结果与历史管理
- 破解成功后，可在"文件"菜单选择"保存破解结果"导出详细报告。
- 所有破解历史会自动记录，可在"设置-历史记录"中查看、导出、复制。

## 3. 常见问题与技巧
- 若在线字典下载失败，可点击"复制地址"用浏览器或下载工具手动下载。
- 破解失败时建议更换字典、调整掩码或尝试其他攻击模式。
- 如遇依赖缺失、路径错误、OpenCL异常，参考"设置-工具路径"或"帮助"菜单进行修复。
- 支持多种文件类型自动识别，无需手动设置哈希类型。

---

如需更详细的操作说明，请查阅帮助菜单或联系开发团队。

# 破解流程开发记录

## 1. 项目结构与技术选型

- **主语言**：Python 3.6+
- **GUI 框架**：PyQt5
- **依赖管理**：requirements.txt
- **外部工具**：Hashcat、John the Ripper（需支持命令行调用）
- **多线程/多进程**：用于防止 UI 阻塞
- **配置管理**：JSON 文件保存用户配置和历史

## 2. 核心模块划分

- `zipcracker_app.py`：主窗口与核心业务逻辑
- `zipcracker_dialogs.py`：所有自定义对话框（字典管理、性能设置、历史等）
- `zipcracker_utils.py`：工具函数（命令行调用、日志、格式化等）
- `zipcracker_models.py`：任务管理、线程模型、数据结构
- `zipcracker_config.py`：配置读写
- `dictionaries/`：本地字典存放目录

## 3. 破解流程主线（开发视角）

### 3.1 哈希提取

- 设计"选择文件"与"提取哈希"按钮
- 用 John the Ripper 的相关脚本（如 zip2john、rar2john）提取哈希
- 提取过程用线程/子进程，避免阻塞 UI
- 提取结果通过信号/回调更新 UI

### 3.2 攻击模式与参数输入

- 攻击模式用 QComboBox + QStackedWidget 切换不同参数输入区
- 支持字典、组合、掩码、混合、暴力等多种模式
- 每种模式下参数校验（如字典路径、掩码格式等）

### 3.3 字典管理

- 本地字典：扫描 `dictionaries/` 目录，支持添加/删除/预览
- 在线字典：维护可用字典列表，支持一键下载/复制下载地址
- 下载用线程，支持进度条和异常提示

### 3.4 破解控制

- "开始破解"按钮启动 Hashcat 线程，参数根据 UI 选择自动拼接
- 破解线程用信号实时回传日志、进度、结果
- "暂停破解"通过 kill 进程+保存 .restore 文件实现
- "继续破解"用 `--restore` 参数恢复 session
- "停止破解"彻底终止进程，重置 UI 状态

### 3.5 进度保存与恢复

- 破解 session 采用 Hashcat 的 `--session` 机制
- 暂停/保存时检测 .restore 文件，允许导出
- 恢复时复制 .restore 文件到 hashcat 目录，自动恢复 session

### 3.6 结果与历史

- 破解成功/失败后弹窗提示，日志记录
- 支持一键复制密码、保存破解结果到文件
- 所有历史自动写入 JSON，支持历史查询、导出

## 4. 关键技术点

- **信号与线程**：所有耗时操作（哈希提取、破解、下载）均用线程，主线程只负责 UI
- **外部工具集成**：用 subprocess/QProcess 调用 hashcat/john，捕获输出
- **异常处理**：所有外部命令、文件操作均 try/except，UI 友好提示
- **配置热加载**：所有路径、性能参数、历史等均用 config 模块读写
- **UI 响应性**：所有 UI 状态变化（按钮可用、进度、日志）都用信号安全更新

## 5. 典型开发流程（伪代码/流程图）

```python
# 1. 用户选择文件
on_choose_file():
    file = QFileDialog.getOpenFileName()
    self.selected_file = file

# 2. 提取哈希（线程）
on_extract_hash():
    thread = Thread(target=extract_hash, args=(self.selected_file,))
    thread.start()

# 3. 用户选择攻击模式和参数
on_attack_mode_changed(index):
    self.attackModeStack.setCurrentIndex(index)

# 4. 开始破解（线程）
on_start_crack():
    params = collect_params_from_ui()
    thread = HashcatThread(params)
    thread.log_signal.connect(update_log)
    thread.finished_signal.connect(on_crack_finished)
    thread.start()

# 5. 暂停/恢复/保存进度
on_pause():
    kill_hashcat()
    check_restore_file()
    enable_save_progress()

on_resume():
    run_hashcat_restore()

# 6. 破解完成
on_crack_finished(result):
    update_ui_with_result(result)
    save_history(result)
```

## 6. 经验与建议

- 先实现最小可用流程（文件选择→哈希提取→字典破解→结果显示），再逐步扩展攻击模式和高级功能
- 所有外部依赖（hashcat、john、OpenCL、perl）都要做路径和可用性检测
- UI 设计要考虑异常和边界情况（如路径丢失、网络失败、破解中断）
- 日志和历史记录对调试和用户体验非常重要
- 字典下载要考虑国内网络环境，提供"复制地址"便于手动下载

---

**建议：下次开发同类工具时，直接参考本开发记录，按模块分工、流程驱动、信号线程分离的思路实现。遇到新需求时，优先扩展 UI 和参数收集层，底层调用 hashcat/john 逻辑保持解耦。**

如需生成更详细的开发手册、类图、流程图或代码模板，请随时告知！ 